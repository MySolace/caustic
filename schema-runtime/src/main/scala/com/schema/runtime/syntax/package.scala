package com.schema.runtime

import Transaction._
import akka.actor.Scheduler
import akka.pattern.after
import scala.concurrent.{ExecutionContext, Future}
import scala.concurrent.duration.FiniteDuration

package object syntax {

  implicit def proxy2txn(proxy: Proxy): Transaction = proxy.path

  implicit def proxy2pimp(proxy: Proxy): RichTransaction = proxy2txn(proxy)

  /**
   * Asynchronously executes the transaction generated by the specified function and returns the
   * result of execution.
   *
   * @param f Transaction generator.
   * @param db Implicit database.
   * @param ec Implicit execution context.
   * @return Result of transaction execution, or an exception on failure.
   */
  def Schema(f: Builder => Unit)(
    implicit ec: ExecutionContext,
    db: Database
  ): Future[String] = {
    val builder = Builder(Literal.Empty)
    f(builder)
    db.execute(builder.txn)
  }

  /**
   * Asynchronously executes the transaction generated by the specified function, returns the result
   * of execution, and automatically retries failures with the specified backoff. Implementation
   * relies on Akka to schedule retries, and is fully compatible with the backoff strategies
   * implemented in Backoff.scala within the Finagle project.
   *
   * @param backoffs Backoff durations.
   * @param f Transaction generator.
   * @param ec Implicit execution context.
   * @param scheduler Implicit Akka scheduler.
   * @param db Implicit database.
   * @return Result of transaction execution, or an exception on retried failure.
   */
  def Schema(backoffs: Stream[FiniteDuration])(f: Builder => Unit)(
    implicit ec: ExecutionContext,
    scheduler: Scheduler,
    db: Database
  ): Future[String] =
    Schema(f).recoverWith { case _ if backoffs.nonEmpty =>
      after(backoffs.head, scheduler)(Schema(backoffs.drop(1))(f))
    }

  /**
   * Returns a proxy to the object specified by its globally unique identifier.
   *
   * @param key Globally unique identifier.
   * @param builder Implicit transaction builder.
   * @return Proxy to the requested object.
   */
  def Select(key: Key)(
    implicit builder: Builder
  ): Proxy = {
    require(!key.contains(FieldDelimiter), "Key may not contain field delimiter.")
    require(!key.contains(ListDelimiter), "Key may not contain list delimiter.")
    Proxy(key)
  }

  /**
   * Deletes the specified object and its various fields. Deletion requires each object to be mapped
   * to the list of its field names so that they may be efficiently purged. Furthermore, each field
   * modification always requires an additional read to verify that the field name is recorded in
   * the list of the corresponding identifier and may require an additional write in case it has not
   * been already recorded. However, the additional read is inexpensive (at least one read is always
   * performed, and reads are batched together) and the additional write is rarely necessary because
   * most applications have relatively static data models. Delete should only be called on reference
   * types, if delete is called on a field is has undetermined behavior.
   *
   * @param proxy Object to delete.
   * @param builder Implicit transaction builder.
   */
  def Delete(proxy: Proxy)(
    implicit builder: Builder
  ): Unit = {
    builder :+ purge(read(proxy))
    builder :+ write(proxy.path, Literal.Empty)
  }

  /**
   * Conditionally branches to the first block if the specified comparison is non-empty and to the
   * second otherwise. Implementation relies on structural types (duck typing), and so the language
   * feature scala.language.reflectiveCalls must be in scope to silence compiler warnings.
   *
   * @param cmp Comparison condition.
   * @param success Required If clause.
   * @param builder Implicit transaction builder.
   * @return Optional Else clause.
   */
  def If(cmp: Transaction)(success: => Unit)(
    implicit builder: Builder
  ) = new {
    private val before = builder.txn
    builder.txn = Literal.Empty
    success
    private val pass = builder.txn
    builder.txn = cons(before, branch(cmp, pass, Literal.Empty))

    def Else(failure: => Unit): Unit = {
      builder.txn = Literal.Empty
      failure
      val fail = builder.txn
      builder.txn = cons(before, branch(cmp, pass, fail))
    }
  }

  /**
   * Appends the value of the specified transactions to the transaction builder. Values are
   * concatenated together into a json array for convenience.
   *
   * @param first First transaction to return.
   * @param rest Other transactions to return.
   * @param builder Implicit transaction builder.
   */
  def Return(first: Transaction, rest: Transaction*)(
    implicit builder: Builder
  ): Unit =
    builder :+ concat("[", concat(
      rest.+:(first)
        .map(t => concat("\"", concat(t, "\"")))
        .reduceLeftOption((a, b) => a ++ "," ++ b)
        .getOrElse(first),
      "]"
    ))

}
